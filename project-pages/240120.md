# Chess Engine in C

In this project, we implement a **chess engine in C**.  

Chess is a fascinating problem from both **computer science** and **machine learning** perspectives. It‚Äôs a **zero-sum**, **perfect-information** game ‚Äî meaning both players have complete visibility of the board ‚Äî yet the **action space** (the number of possible moves) is enormous. This makes efficient computation and intelligent search strategies essential for strong performance.

## ‚öôÔ∏è Core Implementation

Our engine is built around **bitboard representations** and **magic number hashing**, two key techniques that allow extremely fast move generation.  

- **Bitboards** encode the chessboard as 64-bit integers, enabling efficient use of **bitwise operations** to represent and manipulate piece positions.  
- **Magic numbers** are used to compute sliding piece attacks (rooks, bishops, queens) via precomputed lookup tables. This method is both elegant and **highly optimized**, reducing the need for expensive runtime calculations.

The combination of these low-level optimizations allows our move generator to run at speeds **comparable to Stockfish** on similar hardware.

## üß† Search Algorithm

On top of this optimized backbone, we implemented **classical search algorithms** like **Alpha-Beta pruning**, which systematically eliminates large parts of the move tree that cannot influence the final decision.  
This dramatically shrinks the search space and makes it feasible to explore millions of positions per second.

## üöÄ Summary

By leveraging:
- Efficient **bit-level computation**,  
- Smart **magic bitboard techniques**, and  
- Proven **search algorithms**,  

we created a chess engine that‚Äôs both **fast** and **intellectually elegant**, blending classic computer science with practical optimization.
